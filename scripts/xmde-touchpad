#!/bin/bash
#
#   Enable or disable the touchpad.
#   Use `xinput` to get and modify the state of the touchpad.
#   Without argument, print the touchpad state. Otherwise, either turn it `on`,
#   `off` or `toggle` its state.
#

set -e


# First check if synclient is an executable command.
# Without it we cannot do anything so we complain and exit.
#
if ! command -v 'xinput' > '/dev/null' 2> '/dev/null' ; then
    printf "cannot find command 'xinput'\n" >&2
    exit 1
fi


# Xinput operate on input device through their name or id.
# However, the Archwiki says that the id may change. To avoid race condition,
# we only use names.
# Print the name of the first touchpad detected in the system.
#
get_touchpad_name() {
    xinput list \
        | perl -wnle 'm!\s*([\w\s:]*touchpad|synaptics)!i and print $1' \
        | head -n1
}

# Print the state of the first touchpad detected in the system, either 'on' or
# 'off'.
#
get_state() {
    local name="$(get_touchpad_name)"

    if xinput list-props "${name}" | grep -Pq 'Device Enabled.*1\s*$' ; then
	echo 'on'
    else
	echo 'off'
    fi
}

# Change the state of the first touchpad detected in the system to either 'on'
# or 'off'.
#
set_state() {
    local state="$1" ; shift
    local name="$(get_touchpad_name)"

    case "${state}" in
	'on')
	    xinput enable "${name}"
	    ;;
	'off')
	    xinput disable "${name}"
	    ;;
    esac
}


# If there is no argument, print the touchpad state and exit.
#
if [ $# -eq 0 ] ; then
    get_state
    exit 0
fi


# If there is an argument, change the touchpad state.
# The argument is `on`, `off` or `toggle`. Otherwise complain and exit.
#
case "$1" in
    'on')
	set_state 'on'
	;;
    'off')
	set_state 'off'
	;;
    'toggle')
	case "$(get_state)" in
	    'on')
		set_state 'off'
		;;
	    'off')
		set_state 'on'
		;;
	esac
	;;
    *)
	printf "invalid operand '%s'\n" "$1" >&2
	printf "syntax: %s [ on | off | toggle ]\n" "$0" >&2
	exit 1
	;;
esac


# Exit with success after changing the state.
#
exit 0
